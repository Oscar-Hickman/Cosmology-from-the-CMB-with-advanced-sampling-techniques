#Import Packages
import tensorflow as tf
import tensorflow_probability as tfp
import numpy as np
import matplotlib.pyplot as plt
import healpy as hp
import camb 
from camb import model, initialpower
%matplotlib inline


#%%  #Generate a basic map
def basicgenmap(_strt, _stop, _NSIDE):  # (start, stop, NSIDE)
    _NPIX = 12*_NSIDE**2
    return   np.linspace(_strt,_stop,_NPIX)        #set an array to generate a map


#%% #Downloads the higher resolution WMAP data 
!healpy_get_wmap_maps.sh
wmap_map_I = hp.read_map("wmap_band_iqumap_r9_7yr_W_v4.fits")
hp.write_map("my_map.fits", wmap_map_I, overwrite=True)


#%% #Calls Planck power spectrum
pars = camb.CAMBparams()
#This function sets up CosmoMC-like settings, with one massive neutrino and helium set using BBN consistency
pars.set_cosmology(H0=67.5, ombh2=0.022, omch2=0.122, mnu=0.06, omk=0, tau=0.06)
pars.InitPower.set_params(As=2e-9, ns=0.965, r=0)
pars.set_for_lmax(2500, lens_potential_accuracy=0);
#calculate results for these parameters
results = camb.get_results(pars)
powers =results.get_cmb_power_spectra(pars, CMB_unit='muK')
totCL=powers['total']
ls = np.arange(totCL.shape[0])
pars.set_for_lmax(4000, lens_potential_accuracy=2)
results = camb.get_results(pars)
accCL = results.get_lensed_scalar_cls(CMB_unit='muK')[:len(ls),2]
pars.set_for_lmax(6000, lens_potential_accuracy=4)
results = camb.get_results(pars)
refCL = results.get_lensed_scalar_cls(CMB_unit='muK')[:len(ls),2]
plt.figure()
plt.plot(ls,totCL[:len(ls),2], color='C0')
plt.plot(ls,accCL, color='C3')
plt.plot(ls,refCL, color='k')
plt.xlabel(r'$\ell$')
plt.ylabel(r'$\ell(\ell+1)C_\ell^{BB}/2\pi\,[\mu {\rm K}^2]$')
plt.show()
print(accCL)
print(len(accCL))


#%%  #Gives the resolution for an NSIDE and the number of pixels.
def basicmapdet(_NSIDE, _NPIX):     
    print("Approximate resolution at NSIDE {} is {:.2} deg".format(_NSIDE, hp.nside2resol(_NSIDE, arcmin=True) / 60))
    print('Number of pixels =',_NPIX)


#%% #Generate a map given a power spectrum
def genmap(_cls, _NSIDE):   
    return hp.synfast(_cls,_NSIDE ,lmax = (3*_NSIDE-1))


#%% #Generate a power spectrum given cls
def gencls(_map):
    return hp.anafast(_map, lmax=int(((3*(len(_map)/12)**0.5)-1)))    #lmax = 3NSIDE -1 by default


#%% #Plots a given power spectrum 
def plotpwrspctrm(_cls):
    _l = np.arange(len(_cls))
    plt.figure()
    plt.plot(_l, _l * (_l + 1) * _cls)
    plt.xlabel("$\l$")
    plt.ylabel("$\l(\l+1)C_{\l}$")
    plt.grid()
    plt.title("Power Spectrum")
    plt.show()


#%% #Adds random noise to each pixel on a map given a variance 
def noisemap(_map,_var):
    _newmap = []
    _noisevec = []
    for i in range(len(_map)):
        _noisevec.append(np.random.normal(0,_var))
        _newmap.append(_map[i] + _noisevec[-1])
    _newmap = np.array(_newmap)    
    _noisevec = np.array(_noisevec)
    return [_newmap, _noisevec]


#%% #Generate alms given a cls
def genalms(_cl):
    alms = []
    for l in range(len(ell)):
        alms.append([]) 
        for m in range(len(ell)): #set negative m's
            alms[-1].append([np.random.normal(0,0.5*_cl[l]),np.random.normal(0,0.5*_cl[m])])
        alms[-1].append([np.random.normal(0,_cl[l]),0.0])        #set m=0
        for m in range(len(ell)):                    #set positive m's = -m's
            alms[-1].append([alms[l][(len(ell)-m-1)][0]])
            alms[-1][-1].append(-1.0*alms[l][len(ell)-m-1][-1])   #set imag part of positive m's = c.c. of negative m's.
    return alms   


#%% #negative log of the posterior, psi, ignoring the prior term.
psi =0.5*(d-Ya)(n^-1)*()


